<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="description"
   content="Gitless: a simple version control system built on top of Git"/>
  <title>Gitless</title>
  <link rel="stylesheet" type="text/css" href="css/reset.css" />
  <link rel="stylesheet" media="screen" href="css/grid960.css" />
  <link rel="stylesheet" type="text/css" href="css/type.css" />
  <link rel="stylesheet" type="text/css" href="css/helpers.css" />
  <link rel="stylesheet" type="text/css" href="css/custom.css" />
  <link rel="stylesheet" type="text/css"
   href="http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic" />
  <link rel="stylesheet" type="text/css"
   href="http://fonts.googleapis.com/css?family=Droid+Sans:400,700" />
  <link rel="icon" type="image/x-icon" href="favicon.ico" />
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create','UA-61756998-1','auto');ga('send','pageview',{'page':
  location.pathname+location.search+location.hash});
  </script>
</head>

<body>
  <div id="ribbon">
  <a href="https://github.com/sdg-mit/gitless">
    <img style="position: absolute; top: 0; right: 0; border: 0;"
     src="fork-me.png" alt="Fork me on GitHub">
  </a>
  </div>
  <div id="container">

    <div id="header" class="full">
     <span class="header-gl">Gitless</span>
     <p>a simple version control system built on top of Git</p>
    </div>

    <div id="sidebar" class="third news">  
      <!-- Begin Download -->
      <h1><span>Downloads</span></h1>
      <div>
        <p style="margin-top: 2em; font-size: small">Latest release: v0.8.5
        (<a href="https://github.com/sdg-mit/gitless/releases/tag/v0.8.5">release notes</a>)
        <span style="color: gray">Released on Dec 21 2016</span>
        </p>
        <ul>
          <li>
            <a href="https://github.com/sdg-mit/gitless/releases/download/v0.8.5/gl-v0.8.5-darwin-x86_64.tar.gz">
            Mac OS X Binary (.tar.gz)
            </a>
          </li>
          <li>
            <a href="https://github.com/sdg-mit/gitless/releases/download/v0.8.5/gl-v0.8.5-linux-x86_64.tar.gz">
            Linux Binary (.tar.gz)
            </a>
          </li>
          <li>
            <a href="https://github.com/sdg-mit/gitless/archive/v0.8.5.tar.gz">
            Source Code (.tar.gz)
            </a>
          </li>
        </ul>

        <p>
        After installation, you should be able to execute the <code>gl</code>
        command. Gitless is licensed under the 
        <a href="https://github.com/sdg-mit/gitless/blob/master/LICENSE.md">GPL
        v2</a>
        </p>
        <p style="font-size: small">
          <a href="https://github.com/sdg-mit/gitless/blob/master/README.md#install">
          installation instructions</a> |
          <a href="https://github.com/sdg-mit/gitless/blob/master/README.md#install">
          installing via package manager</a> |
          <a href="https://github.com/sdg-mit/gitless/releases">
          previous releases</a>
        </p>

      </div>
      <!-- End Download -->
    </div>
    <!-- Begin Main -->
    <div id="main" class="twothird">
      <h1>About</h1>
      <p>
      Gitless is a version control system built on top of Git.
      Many people complain that Git is hard to use. We think the problem lies
      deeper than the user interface, in the concepts underlying Git. Gitless
      is an experiment to see what happens if you put a simple veneer on an app
      that changes the underlying concepts. Because Gitless is implemented on
      top of Git (could be considered what Git pros call a "porcelain" of Git),
      you can always fall back on Git. And of course your coworkers you share a
      repo with need never know that you're not a Git aficionado.
      </p>

      <p>
      Check out the <a href="#documentation">documentation</a> to get started.
      If you are new to version control, the
      documentation should be enough to get you started. If you are a Git pro
      looking to see what's different from your beloved Git you'll be able to
      spot the differences by glancing through the
      <a href="#vs">Gitless vs. Git</a> section.
      If you are
      interested in software design and want to learn more about the research
      behind Gitless see the 
      <a href="#research">research</a> section.
      </p>
    </div>
    <!-- End Main -->

    <!-- Begin Documentation -->
    <div class="twothird">
      <a id="documentation"><h1>Documentation</h1></a>

      <!-- Begin Documentation/Commands -->

      <h2>Interface</h2>
        <ul>
          <li>
            <code><a href="#gl-init">gl init</a></code>
            - create an empty repo or create one from an existing remote
              repo
          </li>
          <li>
            <code><a href="#gl-status">gl status</a></code>
            - show status of the repo
          </li>
          <li>
            <code><a href="#gl-track">gl track</a></code>
            - start tracking changes to files
          </li>
          <li>
            <code><a href="#gl-untrack">gl untrack</a></code>
            - stop tracking changes to files
          </li>
          <li>
            <code><a href="#gl-diff">gl diff</a></code>
            - show changes to files
          <li>
            <code><a href="#gl-commit">gl commit</a></code>
            - record changes in the local repo
          </li>
          <li>
            <code><a href="#gl-checkout">gl checkout</a></code>
            - checkout committed versions of files
          </li>
          <li>
            <code><a href="#gl-history">gl history</a></code>
            - show commit history
          </li>
          <li>
            <code><a href="#gl-branch">gl branch</a></code>
            - list, create, edit or delete branches
          </li>
          <li>
            <code><a href="#gl-switch">gl switch</a></code>
            - switch branches
          </li>
          <li>
            <code><a href="#gl-tag">gl tag</a></code>
            - list, create, or delete tags
          </li>
          <li>
            <code><a href="#gl-merge">gl merge</a></code>
            - merge the divergent changes of one branch onto another
          </li>
          <li>
            <code><a href="#gl-fuse">gl fuse</a></code>
            - fuse the divergent changes of one branch onto another
          </li>
          <li>
            <code><a href="#gl-resolve">gl resolve</a></code>
            -  mark files with conflicts as resolved
          </li>
          <li>
            <code><a href="#gl-publish">gl publish</a></code>
            - publish commits upstream
          </li>
          <li>
            <code><a href="#gl-remote">gl remote</a></code>
            - list, create, edit or delete remotes
          </li>
        </ul>
      <!-- End Documentation/Commands -->

      <!-- Begin Documentation/Guide -->
      <h2>Guide</h2>
      <p>
      Contents:
        <a href="#repository">Creating a Repository</a>,
        <a href="#changes">Saving Changes</a>,
        <a href="#branching">Branching</a>,
        <a href="#tagging">Tagging</a>,
        <a href="#remote">Working with Remote Repositories</a>.
      </p>
      <a id="repository"><h3>Creating a Repository</h3></a>
      <p>
      Say you are in directory <code>foo</code> and you want turn it into a
      repository. You do this with the
      <code><a id="gl-init">gl init</a></code> command. This transforms
      the current working directory into an empty repository and you
      are now ready to start saving changes to files in <code>foo</code>:
      </p>
      <div class="code">
      <pre><code><span class="shell">$</span> mkdir foo
<span class="shell">$</span> cd foo/
<span class="shell">$</span> gl init
<span class="ansi-green">✔ Local repo created in /MyFiles/foo</span></code></pre>
      </div>
      <p>
      In most cases there's already some existing repository you
      want to work on instead of starting with an empty repository. To make a
      local clone of a remote repository you can give the URL of the repository
      as input to the same <code>gl init</code> command:
      </p>
      <div class="code">
      <pre><code><span class="shell">$</span> mkdir experiment
<span class="shell">$</span> cd experiment/
<span class="shell">$</span> gl init https://github.com/spderosso/experiment
<span class="ansi-green">✔ Local repo created in /MyFiles/experiment</span>
<span class="ansi-green">✔ Initialized from remote https://github.com/spderosso/experiment</span></code></pre>
      </div>
      <a id="changes"><h3>Saving Changes</h3></a>
      <p>
      Now that you have your local repository, it's time to start saving
      changes to files. A file in Gitless can be <em>tracked</em>,
      <em>untracked</em> or <em>ignored</em>.
      A <em>tracked file</em> is a file whose changes Gitless will detect.
      Tracked files are automatically considered for commit if they are
      modified and appear listed under the "Tracked files with modifications"
      section of <code>status</code>.
      Conversely, an <em>untracked file</em> is a file whose changes Gitless
      will not detect. These are not automatically considered for commit and
      appear listed under the "Untracked files" section of
      <code>status</code>.
      Finally, an <em>ignored file</em> is a file that is completely ignored by
      Gitless and it won't even appear in the output of <code>status</code>.
      </p>
      <p>
      An example output of the <code><a id="gl-status">gl status</a></code>
      command
      (<code>foo.py</code> and <code>bar.py</code> are tracked files
      with modifications, <code>.gitignore</code> is an unmodified tracked file,
      <code>baz.py</code> is an untracked file and <code>foo.pyc</code> is an
      ignored file):
      </p>
      <div class="code">
      <pre><code><span class="shell">$</span> ls
bar.py  baz.py  foo.py  foo.pyc .gitignore
<span class="shell">$</span> gl status
On branch <span class="ansi-green">master</span>, repo-directory <span class="ansi-green">//</span>

Tracked files with modifications:
  ➜ these will be automatically considered for commit
  ➜ use gl untrack &lt;f&gt; if you don't want to track changes to file f
  ➜ if file f was committed before, use gl checkout &lt;f&gt; to discard local changes

    <span class="ansi-yellow">foo.py</span>
    <span class="ansi-yellow">bar.py</span>

Untracked files:
  ➜ these won't be considered for commit)
  ➜ use gl track &lt;f&gt; if you want to track changes to file f

    <span class="ansi-blue">baz.py</span></code></pre>
      </div>
      <p>
      Now, how do files move between these three different <em>disjoint</em>
      states?
      </p>
      <p>
      A file is ignored if it's matched by the ignore specification described in
      a <code>.gitignore</code> file.
      In the example above,
      there is a <code>.gitignore</code> file whose content is '*.pyc'; since
      <code>foo.pyc</code> is matched by that pattern it's therefore an
      ignored file.
      </p>
      <p>
      A new file that is not matched by the ignore spec is initially an untracked
      file. If you want to track it you can do so with the
      <code><a id="gl-track">gl track</a></code> command. You can stop tracking
      changes to a tracked file
      with the <code><a id="gl-untrack">gl untrack</a></code> command.
      You can always revert a file back to some previous version with the
      <code><a id="gl-checkout">gl checkout</a></code> command.
      </p>
      <div class="code">
      <pre><code><span class="shell">$</span> gl track baz.py
<span class="ansi-green">✔ File baz.py is now a tracked file</span>
<span class="shell">$</span> gl track baz.py
<span class="ansi-red">✘ File baz.py is already a tracked file</span>
<span class="shell">$</span> gl untrack baz.py
<span class="ansi-green">✔ File baz.py is now an untracked file</span>
<span class="shell">$</span> gl checkout foo.py
You have uncommitted changes in foo.py that would be
overwritten by checkout. Do you wish to continue? (y/N)
&gt; y
<span class="ansi-green">✔ File foo.py checked out successfully to its state at HEAD</span></code></pre>
      </div>
      <p>
      To save changes to files you use
      <code><a id="gl-commit">gl commit</a></code>.
      By default, all tracked modified files are considered
      for commit, but the set of files to commit can be customized with the
      <code>o/only</code>, <code>e/exclude</code>, and <code>i/include</code>
      flags:
      </p>
      <div class="code">
      <pre><code><span class="shell">$</span> gl commit -m "foo and bar"
<span class="shell">$</span> gl commit -m "only foo" -o foo.py
<span class="shell">$</span> gl commit -m "only foo and baz" -o foo.py baz.py
<span class="shell">$</span> gl commit -m "only foo" -e bar.py
<span class="shell">$</span> gl commit -m "only foo and baz" -e bar.py -i baz.py
<span class="shell">$</span> gl commit -m "foo, bar and baz" -i baz.py</code></pre></div>
      <p>
      There's also a <code>p/partial</code> flag that allows you to
      interactively select segments of files to commit.
      <p>
      <p>
      The <code><a id="gl-diff">gl diff</a></code> command can be used to see the
      difference between the working and committed versions of files. Like
      <code>commit</code>, the default set of files to diff is
      the set of all tracked modified files but it can be customized with the
      <code>o/only</code>, <code>e/exclude</code>, and <code>i/include</code>
      flags.
      </p>
      <p>
        To remove files simply do it like you would in
        your operating system (e.g., using Unix's <code>rm</code> command). Gitless
        will detect the change if the file was tracked, and it will appear as removed
        in <code>status</code>. Gitless currently doesn't detect renames. If you rename a file,
        Gitless will interpret this as a file with the old name being removed and a new one
        (with the new name and content) being created. If you want the renamed file to be tracked
        again you need to track it with <code>gl track</code>.
      </p>

 
      <a id="branching"><h3>Branching</h3></a>
      <p>
      A branch is an independent line of development. You are always working
      on some branch. Each branch has its own history (which you can look at
      with the <a id="gl-history">gl history</a> command). Any changes to
      existing files or new files you create on a branch will not be present on
      the other branch when you switch branches.
      </p>
      <p>To create a new branch you use the
      <a id="gl-branch">gl branch</a>
      command. To switch to another branch you use the
      <a id="gl-switch">gl switch</a> command:
      </p>
      <div class="code">
      <pre><code><span class="shell">$</span> gl branch -c develop
<span class="ansi-green">✔ Created new branch develop</span>
<span class="shell">$</span> gl switch develop
<span class="ansi-green">✔ Switched to branch develop</span>
</code></pre>
      </div>
      <p>
      To list all branches:
      </p>
      <div class="code">
      <pre><code><span class="shell">$</span> gl branch
List of branches:
  ➜ do gl branch &lt;b&gt; to create branch b
  ➜ do gl branch -d &lt;b&gt; to delete branch b
  ➜ do gl switch &lt;b&gt; to switch to branch b
  ➜ * = current branch

    <span class="ansi-green">* master</span>
      <span class="ansi-yellow">develop</span>
</code></pre>
      </div>

      <p>
      Each branch has a head, which is the last commit done on the branch.
      By default, the head of a new branch is going to be equal to the
      head of the current branch. If you want a different commit to be the
      head of the new branch you can provide one with the
      <code>dp/divergent-point</code> flag.
      </p>
      <p>
      To specify a commit you can use its id, or you can specify it via an ancestry
      reference with <code>~</code>: <code>HEAD~n</code> refers to
      the nth commit before head.
      </p>
      <p>
      To change the head of the current branch you use the <code>sh/set-head</code> flag.
      The <code>sh</code> flag is useful to, for example, amend the last commit:
      to do so, run <code>gl branch -sh HEAD~1</code>.
      Changing the head of the current branch won't touch your working directory, if you
      additionally want to reset your working directory to match the new head
      you use <code>gl checkout</code>.
      </p>
      <p>
      Eventually branches will end up having divergent
      changes. There are two ways to bring changes from one branch onto the
      current branch: <em>merge</em> and <em>fuse</em>.
      </p>
      <p>
      <em>Merging branches.</em>
      For merging the changes in <code>develop</code> onto the current branch
      you do <code><a id="gl-merge">gl merge develop</a></code>. This creates
      a new merge commit that includes the changes in <code>develop</code> in
      addition to those changes in the current branch:
      </p>
      <div class="fig">
        <img src="merge.png" alt="merge">
      </div>


      <p>
      <em>Fusing branches.</em> Fusing branches gives you more control than
      merging. When you fuse changes from some branch onto the
      current branch you can specify the commits to fuse and the insertion
      point. By default, all divergent commits are fused and the insertion
      point is the divergent point (the point where the source branch diverged
      from the current).
      For example, the following figure depicts a situation in which there are
      two branches: <code>master</code> (the current branch) and
      <code>develop</code>. The last commit these two branches have in common is
      <code>A</code>. This commit is the "divergent point" (because
      it is the point at which <code>master</code> and <code>develop</code>
      diverged).
      After doing <code><a id="gl-fuse">gl fuse develop</a></code>, the commits
      in <code>develop</code> are inserted in <code>master</code> after the
      divergent point:
      </p>
      <div class="fig">
        <img src="fuse.png" alt="fuse" class="fig">
      </div>
      <p>
      To choose other insertion points you use the
      <code>ip/insertion-point</code> flag. You can give a commit id as input,
      <code>head</code> or <code>dp/divergent-point</code>:
      </p>
      <div class="fig">
        <img src="fuse_ip.png" alt="fuse with insertion point specified">
      </div>
      <p>
      The <code>o/only</code> and <code>e/exclude</code> flags can be used to
      customize the set of commits to be fused:
      </p>
      <div class="fig">
        <img src="fuse_ip_o.png"
         alt="fuse with insertion point and commit specified">
      </div>
      <p>
      During this process conflicts could occur. If so, the <code>gl status</code> command will change
      accordingly to indicate the files in conflict. Once you edit those files in
      conflict you mark them as resolved with
      <code><a id="gl-resolve">gl resolve</a></code> (passing the files to mark as input). Once all
      conflicts have been resolved
      you do <code>gl commit</code> to commit to continue with the fuse or
      merge.
      </p>
      <p>
      A branch can have an "upstream branch." If a branch has an upstream
      associated with it, then <code>gl fuse</code> or <code>gl merge</code> can
      be used as shorthands for <code>gl {fuse, merge} upstream_branch</code>.
      To set an upstream branch for the current branch use
      <code>gl branch -su upstream_branch</code>.
      </p>


      <a id="tagging"><h3>Tagging</h3></a>
      <p>
      You use tags to signify a commit is special in some way. For example, you
      can use <code><a id="gl-tag">gl tag</a></code> to create a tag with name
      "v1.0" and make it point to the commit that represents release v1.0:
      </p>
      <div class="code">
      <pre><code><span class="shell">$</span> gl tag -c v1.0
<span class="ansi-green">✔ Created new tag v1.0</span>
</code></pre>
      </div>
      <p>In this case, the tag will point to the head of the current branch, but
      you can tag other commits with the <code>ci/commit</code> flag.
      </p>
      <p>
      To list all tags:
      </p>
      <div class="code">
      <pre><code><span class="shell">$</span> gl tag
List of tags:
  ➜ do gl tag &lt;t&gt; to create tag t
  ➜ do gl tag -d &lt;t&gt; to delete tag t

    v1.0 ➜  tags <span class="ansi-yellow">311bf7c</span> Ready to release
</code></pre>
      </div>


      <a id="remote"><h3>Working with Remote Repositories</h3></a>
      <p>
      To refer to a remote repository you could always use its URL, but an
      easier alternative is to add the repository as a "remote" with the
      <code><a id="gl-remote">gl remote</a></code> command:
      </p>
      <div class="code"><pre><code><span class="shell">$</span> gl remote -c experiment https://github.com/spderosso/experiment
<span class="ansi-green">✔ Remote experiment mapping to https://github.com/spderosso/experiment created
successfully</span>
  ➜ to list existing remotes do gl remote
  ➜ to remove experiment do gl remote -d experiment
</code></pre></div>
      <p>
      Now you can use <code>experiment</code> to refer to this remote repository
      and use <code>experiment/some-branch</code> to refer to the branch of name
      <code>some-branch</code> that lives in <code>experiment</code>.
      </p>
      <p>
      <em>Downloading Changes.</em>
      It is also possible to fuse or merge changes from remote
      branches. For example, doing <code>gl merge experiment/master</code>
      would merge changes in that remote branch that are not present in your
      local current branch. You can also use <code>gl fuse</code>.
      </p>
      <p>
      <em>Uploading Changes.</em>
      To send changes upstream you use
      <code><a id="gl-publish">gl publish</a></code>. The publish command will
      default to updating the upstream branch of the current branch if none is
      given as input.
      </p>
      <p>
      <em>Creating, Deleting, or Listing Remote Branches.</em>
      To create, delete, or list remote branches you use the same <code>gl branch</code>
      command that you use for local branches. If you do
      <code>gl branch -c experiment/develop</code> this will create a branch
      <code>develop</code> that lives in the remote <code>experiment</code>.
      Recall that, by default, the head of this new branch will be equal to the head of
      the current branch, so all commits that are not present in the remote
      will be uploaded. To list remote branches use the
      <code>r/remote</code> flag of <code>gl branch</code>.
      </p>
      <p>
      <em>Creating, Deleting, or Listing Remote Tags.</em>
      To create or delete remote tags you use the <code>gl tag</code> command.
      If you do
      <code>gl tag -c experiment/v1.0</code> this will create a new tag
      <code>v1.0</code> that lives in the remote <code>experiment</code>. You can also list
      remote tags with the <code>r/remote</code> flag of <code>gl tag</code>.
      </p>

      <p>
      When you create a local repository from a remote (by passing a URL as
      input to the <code>gl init</code> command), a local branch is created
      for each remote branch, and each local branch is automatically configured
      to have as upstream its remote counterpart.
      </p>
  

      <!-- End Documentation/Guide -->
    </div>
    <!-- End Documentation -->

    <!-- Begin Versus -->
    <div class="twothird">
      <a id="vs"><h1>Gitless vs. Git</h1></a>

      <!-- Begin Versus/Changes -->
      <h2>Saving Changes</h2>
      <p>There's no staging area in Gitless. This, coupled with a flexible
      commit command makes saving changes to the repository very
      straightforward:
      </p>

      <div class="code vs">
        <pre class="gl"><code><span class="task">Commit all modified tracked files</span>
<span class="shell">$</span> gl commit
<span class="comment">The default set of files to be committed are all
modified tracked files</span>

<span class="task">Leave some modified tracked files (`foo`, `bar`)
out of the commit</span>
<span class="shell">$</span> gl commit -e foo bar
<span class="comment">e/exclude excludes files from the default set
of files to be committed</span>

<span class="task">Include some untracked files in the commit</span>
<span class="shell">$</span> gl commit -i foo2 bar2
<span class="comment">i/include includes files to the default set
of files to be committed</span>

<span class="task">Commit only some of the modified tracked files</span>
<span class="shell">$</span> gl commit -o foo3 bar3
<span class="comment">o/only restricts the set of files to be committed
to only the specified ones</span>

<span class="task">Commit only some of the modified tracked or
untracked files</span>
<span class="shell">$</span> gl commit -o foo3 bar3 foo4
</code>
</pre>
<pre class="git">
<code><span class="task">Commit all modified tracked files</span>
<span class="shell">$</span> git commit -a
<span class="comment">-a/--all automatically stages files that have been
modified or deleted</span>

<span class="task">Leave some modified tracked files (`foo`, `bar`)
out of the commit</span>
<span class="shell">$</span> git add <span class="comment">all files you want to commit minus foo bar</span>
<span class="shell">$</span> git commit


<span class="task">Include some untracked files in the commit</span>
<span class="shell">$</span> git add foo2 bar2 <span class="comment">+ other files you want to commit</span>
<span class="shell">$</span> git commit


<span class="task">Commit only some of the modified tracked files</span>
<span class="shell">$</span> git commit foo3 bar3



<span class="task">Commit only some of the modified tracked or
untracked files</span>
<span class="shell">$</span> git commit foo3 bar3 foo4
error: pathspec 'foo4' did not match any file(s)
known to git.
<span class="comment">...hmm ok... </span>
<span class="shell">$</span> git add foo4
<span class="shell">$</span> git commit foo3 bar3 foo4</code></pre>
      <div style="clear:both"></div>
      </div>
      <p>Also, you can change the classification of any file to tracked,
      untracked or ignored, it doesn't matter whether the file exists at head
      or not:
      </p>
      <div class="code vs">
        <pre class="gl"><code><span class="shell">$</span> gl status
...
Tracked files with modifications:
...
  <span class="ansi-yellow">foo</span>
...

<span class="task">Stop tracking changes to `foo`</span>
<span class="shell">$</span> gl untrack foo
<span class="ansi-green">✔ File foo is now an untracked file</span>
<span class="comment">Now `foo` won't be automatically considered for
commit</span>
<span class="shell">$</span> gl status
...
Untracked files:
...
  <span class="ansi-blue">foo (exists at head)</span>
...

<span class="task">Start tracking changes to `foo` again</span>
<span class="shell">$</span> gl track foo
<span class="ansi-green">✔ File foo is now a tracked file</span>
<span class="comment">Now `foo` will be automatically considered for commit</span>
<span class="shell">$</span> gl status
...
Tracked files with modifications:
...
  <span class="ansi-yellow">foo</span>
...
</code></pre>
<pre class="git"><code><span class="shell">$</span> git status
...
Changes not staged for commit:
...
  <span class="ansi-red">modified: foo</span>
...

<span class="task">Stop tracking changes to `foo`</span>
<span class="comment">No way to do this, if you want to prevent the
accidental commit of `foo` you can do `git add` of
all files but `foo` everytime you do a commit.
Alternatively, you can ignore the file by marking it
as assumed unchanged</span>
<span class="shell">$</span> git update-index --assume-unchanged foo
<span class="comment">Now the file behaves as if it were ignored</span>
<span class="shell">$</span> git status
...
<span class="comment">`foo` won't appear listed in status</span>

<span class="task">Start tracking changes to `foo` again</span>
<span class="shell">$</span> git update-index --no-assume-unchanged foo
<span class="shell">$</span> git status
...
Changes not staged for commit:
...
  <span class="ansi-red">modified: foo</span>
...


</code></pre>
        <div style="clear:both"></div>
      </div>
      <!-- End Versus/Changes -->

      <!-- Begin Versus/Branching -->
      <h2>Branching</h2>
      <p>
      The main thing to understand is that in Gitless a branch is a completely
      independent line of development. Each branch keeps its working version
      of files separate from each other. Whenever you switch to a different
      branch, the contents of your working directory are saved, and the ones
      corresponding to the branch you are switching to are retrieved. The
      classifications of files are also saved (i.e., a file can
      be untracked on some branch but tracked on another and Gitless will
      remember this):
      </p>
      <div class="code vs">
        <pre class="gl"><code><span class="shell">$</span> gl status
...
Tracked files with modifications:
...
  <span class="ansi-yellow">foo</span>
...

<span class="task">Create new branch `develop`</span>
<span class="shell">$</span> gl branch -c develop
<span class="ansi-green">✔ Created new branch develop</span>

<span class="task">Switch to `develop`</span>
<span class="shell">$</span> gl switch develop
<span class="ansi-green">✔ Switched to branch develop</span>
<span class="shell">$</span> gl status
<span class="comment">... no changes to foo here</span>




<span class="task">Switch back to `master`</span>
<span class="shell">$</span> gl switch master
<span class="ansi-green">✔ Switched to branch master</span>
<span class="shell">$</span> gl status
...
Tracked files with modifications:
...
  <span class="ansi-yellow">foo</span>
...
<span class="comment">If you want the uncommitted changes to follow you
into the new branch you can use the mo/move-over
flag to move over the changes in the current branch
to the destination branch</span>
</code></pre>
<pre class="git"><code><span class="shell">$</span> git status
...
Changes not staged for commit:
...
  <span class="ansi-red">modified: foo</span>
...

<span class="task">Create new branch `develop`</span>
<span class="shell">$</span> git branch develop


<span class="task">Switch to `develop`</span>
<span class="shell">$</span> git checkout develop
<span class="shell">$</span> git status
...
Changes not staged for commit:
...
  <span class="ansi-red">modified: foo</span>
...

<span class="task">Switch back to `master`</span>
<span class="shell">$</span> git checkout master
...
Changes not staged for commit:
...
  <span class="ansi-red">modified: foo</span>
...





</code>
</pre>
<div style="clear:both"></div>
      </div>
      <p>
      This means that in Gitless you don't have to worry about uncommitted
      changes conflicting with the changes in the destination branch:
      </p>
      <div class="code vs">
        <pre class="gl"><code><span class="comment">Say we have uncommitted changes to `foo` that
conflict with the state of `foo` in branch `develop`</span>

<span class="task">Switch to `develop`</span>
<span class="shell">$</span> gl switch develop
<span class="ansi-green">✔ Switched to branch develop</span>
</code>
</pre>
<pre class="git">
<code><span class="comment">Say we have uncommitted changes to `foo` that
conflict with the state of `foo` in branch `develop`</span>

<span class="task">Switch to `develop`</span>
<span class="shell">$</span> git checkout develop
error: Your local changes to the following files
would be overwritten by checkout:
     foo
Please, commit your changes or stash them before
you can switch branches.
Aborting
<span class="shell">$</span> git stash
Saved working directory and index state WIP on
master: fbe3b8c ...
HEAD is now at fbe3b8c ...
<span class="shell">$</span> git checkout develop
Switched to branch 'develop'
</code></pre>
<div style="clear:both"></div>
      </div>
      <p>
      And if you are in the middle of a fuse/merge and you want to put aside
      the conflict resolution for later, you can. The conflict will be there
      when you switch back:
      </p>
      <div class="code vs">
        <pre class="gl"><code><span class="shell">$</span> gl fuse develop
...
<span class="ansi-red">✘  There are conflicts you need to resolve</span>
<span class="shell">$</span> gl status
On branch master, repo-directory //

You are in the middle of a fuse; all
conflicts must be resolved before
committing
...
Tracked files with modifications:
...
  <span class="ansi-red">foo (with conflicts)</span>
...









<span class="task">Switch to `bugfix`</span>
<span class="shell">$</span> gl switch bugfix
<span class="ansi-green">✔ Switched to branch bugfix</span>
<span class="comment">No conflicts here</span>















<span class="task">Switch back to `develop`</span>
<span class="shell">$</span> gl switch develop
<span class="ansi-green">✔ Switched to branch develop</span>
<span class="shell">$</span> gl status
On branch master, repo-directory //

You are in the middle of a fuse; all
conflicts must be resolved before
committing
...
Tracked files with modifications:
...
  <span class="ansi-red">foo (with conflicts)</span>
...
</code></pre>
<pre class="git"><code><span class="shell">$</span> git rebase develop
First, rewinding head to replay your work on top of
it...
Applying: this commit should trigger a conflict
Using index info to reconstruct a base tree...
M foo
Falling back to patching base and 3-way merge...
Auto-merging foo
CONFLICT (content): Merge conflict in foo
Failed to merge in the changes.
Patch failed at 0001 foo conflict
The copy of the patch that failed is found in:
   ...
<span class="shell">$</span> git status
rebase in progress; onto 989269e
You are currently rebasing branch 'master' on
'989269e'.
  ...
Unmerged paths:
  ...
  both modified:   foo
...

<span class="task">Switch to `bugfix`</span>
<span class="shell">$</span> git checkout bugfix
foo: needs merge
error: you need to resolve your current index first
<span class="comment">Maybe stash works?</span>
<span class="shell">$</span> git stash
foo: needs merge
foo: needs merge
foo: unmerged (0b3c542edb2e9e8ff801c669d7a5f2d78...)
foo: unmerged (94421333de34e32405f632d0f7b63b39c...)
foo: unmerged (eb97dba229aab53fe5f231e60491dd2a7...)
fatal: git-write-tree: error building trees
Cannot save the current index state
<span class="comment"> ...hmm..ok...</span>
<span class="shell">$</span> <span class="comment">save all the changes to files somewhere else</span>
<span class="shell">$</span> git rebase --abort
<span class="shell">$</span> git checkout bugfix
Switched to branch 'bugfix'

<span class="task">Switch back to `develop`</span>
<span class="shell">$</span> git checkout develop
<span class="shell">$</span> git status
...
<span class="comment">We aborted the rebase to be able to switch branches,
so there's nothing here now</span>
<span class="shell">$</span> git rebase develop
... <span class="comment">same conflict as before</span>
<span class="shell">$</span> <span class="comment">Copy back the changes we saved</span>





</code></pre>
        <div style="clear:both"></div>
      </div>
      <!-- End Versus/Branching -->

      <!-- Begin Versus/Syncing -->
      <h2>Working with Remote Repositories</h2>
      <p>
      Syncing with other repositories in Gitless works quite similar to
      Git:
      </p>
      <div class="code vs">
        <pre class="gl"><code><span class="task">Configure a new remote `experiment`</span>
<span class="shell">$</span> gl remote -c experiment
https://github.com/spderosso/experiment
<span class="ansi-green">✔ Remote experiment mapping to
https://github.com/spderosso/experiment
created successfully</span>
  ➜ to list existing remotes do gl remote
  ➜ to remove experiment do gl remote -d experiment

<span class="task">Download and apply changes from a branch in
`experiment`</span>
<span class="shell">$</span> gl fuse experiment/master
...
<span class="ansi-green">✔ Fuse succeeded</span>
<span class="comment">If you instead want to merge the changes, you
can do `gl merge experiment/master`</span>

<span class="comment">You can also set an upstream for the current branch</span>
<span class="shell">$</span> gl branch -su experiment/master
<span class="ansi-green">✔ Current branch master set to track
experiment/master</span>
<span class="shell">$</span> gl fuse 
<span class="ansi-yellow">! No src branch specified, getting changes from
upstream branch experiment/master</span>
...
<span class="ansi-green">✔ Fuse succeeded</span>

<span class="task">Send changes to the remote</span>
<span class="shell">$</span> gl publish
<span class="ansi-yellow">! No src branch specified, sending changes to
upstream branch experiment/master</span>
<span class="ansi-green">✔ Publish succeeded</span>
<span class="comment">Only the changes in the current branch are uploaded</span></code></pre>
<pre class="git">
<code><span class="task">Configure a new remote `experiment`</span>
<span class="shell">$</span> git remote add experiment
https://github.com/spderosso/experiment






<span class="task">Download and apply changes from a branch in
`experiment`</span>
<span class="shell">$</span> git pull experiment/master
...
<span class="comment">If you instead want to rebase the changes, you can
do `git pull --rebase experiment/master`</span>

<span class="comment">You can also set an upstream for the current branch</span>
<span class="shell">$</span> git branch --set-upstream master experiment/master
<span class="shell">$</span> git pull
...







<span class="task">Send changes to the remote</span>
<span class="shell">$</span> git push
<span class="comment">What happens when you do a push depends on the value
of the `push.default` config variable</span>


</code></pre>
        <div style="clear:both"></div>
      </div>
      <!-- End Versus/Syncing -->

    </div>
    <!-- End Versus -->

    <!-- Begin Research -->
    <div class="twothird">
      <a id="research"><h1>Research</h1></a>
      <p>
      Here's a list of papers related to Gitless:
      </p>
      <ul>
        <li>
        <a href="http://people.csail.mit.edu/sperezde/oopsla16.pdf"
          title="pdf - Purposes, Concepts, Misfits, and a Redesign of Git">
          Purposes, Concepts, Misfits, and a Redesign of Git</a><br/>
        S. Perez De Rosso and D. Jackson.
        In <em>Proceedings of the 2016 ACM SIGPLAN International
        Conference on Object-Oriented Programming, Systems, Languages, and
        Applications (OOPSLA 2016)</em>
        </li>
        <li>
        <a href="http://people.csail.mit.edu/sperezde/onward13.pdf"
          title="pdf - What's Wrong with Git? A Conceptual Design Analysis">
          What's Wrong with Git? A Conceptual Design Analysis</a><br/>
        S. Perez De Rosso and D. Jackson.
        In <em>Proceedings of the 2013 ACM International Symposium on New
        Ideas, New Paradigms, and Reflections on Programming &amp; Software
        (Onward! 2013)</em>
        </li>
      </ul>

    </div>
    <!-- End Research -->

    <!-- Begin Footer -->
    <div id="footer" class="full top_margin_20">
      <p>
      &copy; 2016 <a href="http://people.csail.mit.edu/sperezde">Santiago Perez De Rosso</a>
      </p>
      <p>
      <em>Acknowledgements.</em> Gitless is part of a research project exploring
      concept design. This research is part of a collaboration between MIT and
      SUTD (the Singapore University of Technology and Design), and is funded by
      a grant from SUTD's International Design Center
      </p>
      <p>
      <em>Privacy policy.</em> This website, like a gazillion other websites,
      uses Google Analytics. We use the information (anonymously) collected by
      Google Analytics to track the number of visits, downloads and other 
      relevant information.
      If you want, you can easily opt-out of Google Analytics tracking
      software (there are many ways to do so which you can find online)
      </p>
    </div>
    <!-- End Footer -->
  </div>
</body>
</html>
